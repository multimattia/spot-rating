---
import type { PlaylistTrackObject } from "../types/spotifyTypes";
import { Image } from "astro:assets";

let playlistDataArray: PlaylistTrackObject[];

const { id } = Astro.props;

let allTracksFetched;
if ("trackData" in Astro.props && Array.isArray(Astro.props.trackData)) {
  playlistDataArray = Astro.props.trackData as PlaylistTrackObject[];
  allTracksFetched = playlistDataArray.length < 100;
} else {
  console.error("playlistData is not an array");
  playlistDataArray = [];
}

function formatDuration(durationMs: number) {
  const minutes = Math.floor(durationMs / 60000);
  const seconds = Math.floor((durationMs % 60000) / 1000);
  return `${minutes}:${seconds.toString().padStart(2, "0")}`;
}
---

<div class="main-list">
  <playlist-id
    data-id={id}
    data-all-fetched={allTracksFetched ? "yes" : "no"}
    class="playist-cluster"
  >
    <div class="desc header">
      <p id="track-header">Title</p>
      <p id="artist-names">Artist</p>
      <p id="added-name">Added by</p>
      <p id="duration-length">Duration</p>
    </div>
    {
      playlistDataArray.map((item, index) => (
        <div class="playlist">
          {/* <p>{JSON.stringify(item)}</p> */}
          {/* <p style="min-width: 1.2rem">{index + 1}</p> */}
          <div class="desc">
            <div class="track-cluster">
              <Image
                src={
                  item.track?.album?.images[0]?.url
                    ? item.track?.album?.images[0]?.url
                    : "https://kagi.com/proxy/360_F_248426448_NVKLywWqArG2ADUxDq6QprtIzsF82dMF.jpg?c=l0oPx0FvhjhG2vnK29uE37OLQc-WdefmvQp_UcLKL29LDJEkeYiVhvf2KWXWGustLbBUuFUVTrSjFGd_d3GuBmPOffiZmHemGi6a-Uj_O0D_Dbnq01_FkRla6Ecmv6akMJ1xYVkRKnmiEtwwYeItBw%3D%3D"
                }
                alt=""
                width="50"
                height="50"
              />
              <p id="track-name">{item.track.name}</p>
            </div>
            <p id="artist-names">
              {item.track.artists.map((artist) => artist.name).join(", ")}
            </p>
            <p id="added-name">
              {item.added_by.id ? item.added_by.id : "Spotify"}
            </p>
            <p id="duration-length">{formatDuration(item.track.duration_ms)}</p>
          </div>
        </div>
      ))
    }
  </playlist-id>
  <p id="loading-indicator">Loading...</p>
  <div class="test"></div>
</div>

<style>
  * {
    font-family: Helvetica, sans-serif;
  }

  .main-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  #track-header {
    margin-left: 1rem;
  }

  .desc p {
    width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #track-name {
    width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .track-cluster {
    display: flex;
    gap: 1rem;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .playlist {
    height: 5rem;
  }

  .playlist img {
    margin-left: 1rem;
  }

  .desc {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    width: 100%;
    display: grid;
    grid-template-columns: 3fr repeat(3, 1fr);
    grid-template-rows: 1fr;
    gap: 1rem;
  }

  .desc p {
    text-overflow: ellipsis;
    text-align: start;
  }

  .playlist {
    display: flex;
    align-items: center;
    gap: 3.7rem;
    border-top: 1px solid #ececec;
  }

  .playlist:nth-of-type(even) {
    background-color: #fafafb;
  }

  .playlist:hover {
    background-color: #ebebeb;
    transition: all 0.2s ease-out;
  }

  #loading-indicator {
    margin: 0 auto;
    background-color: gray;
    padding: 10rem 10rem;
    display: none;
  }
</style>

<script>
  interface SpotifyTrack {
    track: {
      album: {
        images: {
          height: number;
          url: string;
          width: number;
        }[];
        name: string;
      };
      artists: {
        name: string;
      }[];
      duration_ms: number;
      name: string;
      popularity: number;
    };
    added_by: {
      id: string;
    };
    added_at: string;
  }
  let offset = 100;
  let loadingTracks = false;
  let id: string;
  let allTracksLoaded = false;

  function debounce<T extends (...args: any[]) => void>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout | undefined;
    return (...args: Parameters<T>): void => {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  const formatDuration = (durationMs: number) => {
    const minutes = Math.floor(durationMs / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  const createPlaylistElement = (
    fetchedTrack: SpotifyTrack
  ): HTMLDivElement => {
    const playlistDiv = document.createElement("div");
    playlistDiv.className = "playlist";

    const descDiv = document.createElement("div");
    descDiv.className = "desc";
    playlistDiv.appendChild(descDiv);

    const cluster = document.createElement("div");
    cluster.className = "track-cluster";
    descDiv.appendChild(cluster);

    const image = document.createElement("img");
    image.src = fetchedTrack.track.album.images[2]?.url
      ? fetchedTrack.track.album.images[2].url
      : "https://kagi.com/proxy/360_F_248426448_NVKLywWqArG2ADUxDq6QprtIzsF82dMF.jpg?c=l0oPx0FvhjhG2vnK29uE37OLQc-WdefmvQp_UcLKL29LDJEkeYiVhvf2KWXWGustLbBUuFUVTrSjFGd_d3GuBmPOffiZmHemGi6a-Uj_O0D_Dbnq01_FkRla6Ecmv6akMJ1xYVkRKnmiEtwwYeItBw%3D%3D";
    image.alt = "";
    image.width = 50;
    image.height = 50;
    cluster.appendChild(image);

    const nameHeading = document.createElement("p");
    nameHeading.textContent = fetchedTrack.track.name;
    cluster.appendChild(nameHeading);

    const artistsHeading = document.createElement("p");
    artistsHeading.textContent = fetchedTrack.track.artists
      .map((artist) => artist.name)
      .join(",");
    descDiv.appendChild(artistsHeading);

    const addedByPara = document.createElement("p");
    addedByPara.textContent = fetchedTrack.added_by.id;
    descDiv.appendChild(addedByPara);

    const durationPara = document.createElement("p");
    durationPara.textContent = formatDuration(fetchedTrack.track.duration_ms);
    descDiv.appendChild(durationPara);

    return playlistDiv;
  };

  const isNearBottom = (): boolean => {
    const threshold: number = 20;
    const position: number = window.scrollY + window.innerHeight;
    const height: number = document.documentElement.scrollHeight;
    return position > height - threshold;
  };

  const handleScroll = () => {
    let fetchedData: SpotifyTrack[] = [];
    if (isNearBottom() && offset < 800 && !loadingTracks && !allTracksLoaded) {
      console.log("Reached End of page.");
      console.log("showing loading...");
      document.getElementById("loading-indicator").style.display = "block";
      const playlistElement = document.querySelector("playlist-id");
      loadingTracks = true;
      fetch(`/api/playlists/${id}/${offset}/tracks/`)
        .then((response) => {
          console.log(response);
          return response.json();
        })
        .then((data) => {
          // Handle the response data
          console.log(data);
          console.log("hiding load");
          document.getElementById("loading-indicator").style.display = "none";
          data.items.forEach((song: SpotifyTrack) =>
            playlistElement?.appendChild(createPlaylistElement(song))
          );
          offset = offset + 100;
          if (data.items.length < 100) {
            allTracksLoaded = true;
          }
          loadingTracks = false;
        })
        .catch((error) => {
          // Handle any errors
          console.error("Error:", error);
          fetchedData = [];
        });

      styleElement.textContent = cssContent;
    }
  };

  const styleElement = document.createElement("style");
  const cssContent = `
  * {
    font-family: Helvetica, sans-serif;
  }
  .main-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .header #track-name {
    margin-left: 1rem;
  }

  .track-cluster {
    display: flex;
    gap: 1rem;
  }

  .playlist {
    height: 5rem;
  }

  .playlist img {
    margin-left: 1rem;
  }

  .desc {
    text-overflow: ellipsis;
    width: 100%;
    display: grid;
    grid-template-columns: 3fr repeat(3, 1fr);
    grid-template-rows: 1fr;
    gap: 1rem;
  }

  .desc p {
    text-overflow: ellipsis;
    text-align: start;
  }

  .playlist {
    display: flex;
    align-items: center;
    gap: 3.7rem;
    border-top: 1px solid #ececec;
  }

  .playlist:nth-of-type(even) {
    background-color: #fafafb;
  }

  .playlist:hover {
    background-color: #ebebeb;
    transition: all 0.2s ease-out;
  }

  #loading-indicator {
    margin: 0 auto;
    background-color: gray;
    padding: 10rem 10rem;
    display: none;
  }
  `;

  const debouncedScroll = debounce(handleScroll, 200);
  window.addEventListener("scroll", debouncedScroll);

  class TrackListing extends HTMLElement {
    constructor() {
      super();
      document.head.appendChild(styleElement);
      console.log(this.dataset.allFetched);
      styleElement.textContent = cssContent;
      // Read the message from the data attribute.
      id = this.dataset.id ? this.dataset.id : "";
      allTracksLoaded = this.dataset.allFetched === "yes" ? true : false;
    }
  }
  customElements.define("playlist-id", TrackListing);
</script>
